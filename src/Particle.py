# -*- coding: utf-8 -*-
"""
Created on Thu May  5 14:50:51 2016 
It would be nice to sleep, but I'm doing it

@author: Алена
"""
import numpy as np
import math

class Qubit:
    
    def __init__(self,probability_1=None):
        if probability_1==None:
            probability_1=np.random.random()
        probability_2=math.sqrt(1-(probability_1**2))
        self.qubit=np.array([[probability_1,probability_2]])
    
    def __repr__(self): #a method for outputting a qubit
        return "qubit: " + str(self.qubit)
        
class Hadamard():
    def __init__(self): 
        self.apply_Hadamard = np.array([1/math.sqrt(2),1/math.sqrt(2)],[1/math.sqrt(2),-1/math.sqrt(2)])
    
    def __repr__(self): #a method for outputting a qubit
        return "Hadamard: " + str(self.apply_Hadamard)
        
class NOT():
    def __init__(self):
        self.apply_NOT = np.array([0,1],[1,0])
        
    def __repr__(self): 
        return "NOT: " + str(self.apply_NOT)
        
class Phase_gate():
    def __init__(self):
        a = complex(0,1)
        a = a.imag
        self.apply_phase_gate = np.array([1,0],[0,a])
        
    def __repr__(self): 
        return "Phase_gate: " + str(self.apply_phase_gate)
        
class Gate_pi():
    def __init__(self):
        p = complex(0,math.pi/4)
        p = p.imag
        self.apply_gate_pi = np.array([1,0],[0,p])
        
    def __repr__(self): 
        return "Gate_pi: " + str(self.apply_gate_pi)
        
class Gate_pi8():
    def __init__(self,n):
        p = complex(0,math.pi/8)
        p = p.imag
        self.apply_gate_pi8 = np.array([[math.exp(-p*n),0],[0,math.exp(p*n)]])
        
    def __repr__(self): 
        return "Gate_pi8: " + str(self.apply_gate_pi8)
        
class CNOT():
    def __init__(self):
        self.apply_CNOT = np.array([1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0])
        
    def __repr__(self): 
        return "Gate_CNOT: " + str(self.apply_CNOT)
        
        
        
        
        
        

class Actor():
    def __init__(self, quantity_bas,long_message):#This class
    #constructor generator. Set the number of bases used and the message length
        self.long_message = long_message
        self.quantity_bas = quantity_bas

    def send(self):
        #This function is used for a random mixing bases and polarizations.
    #Their use Alice and Bob. But if you need something to mix, call this function.
        a=0
        self.message_qubit=[]
        self.randomly_bases=np.random.randint(0,int(self.quantity_bas),self.long_message)
        while a<self.long_message:
            i=np.random.choice([0,1])
            q=Qubit(i)
            self.message_qubit.append(q.qubit)
            a=a+1
            
            

class Alice(Actor):#Here they take their randomly values
            
    def get_randomly_bases_alice(self):
        self.send()
        self.she_send_randomly_bases=self.randomly_bases
        return self.she_send_randomly_bases
        
    def send_qubits_alice(self):
        self.qubits_alice=[]
        i=0
        while i<self.long_message:
            q=Gate_pi8(self.she_send_randomly_bases[i])
            c=np.dot(self.message_qubit[i],q.apply_gate_pi8)
            self.qubits_alice.append(c)
            i=i+1
        
    
        
class Bob(Actor):
              
    def get_randomly_bases_bob(self):
        self.send()
        self.he_send_randomly_bases=self.randomly_bases
        return self.he_send_randomly_bases
        
    def received_qubits_bob(self):
        self.qubits_bob=[]
        i=0
        while i<self.long_message:
            q=Gate_pi8(self.he_send_randomly_bases[i])
            c=np.dot(self.message_qubit[i],q.apply_gate_pi8)
            self.qubits_bob.append(c)
            i=i+1
        

        
class Various_measurement(Alice,Bob,Actor):
    
    def compare_bob_alice(self): #Alice and Bob compare their bases and this
    #forms the following key. If the bases are equal to the true value,
    #if not - then the value of Bob
        self.taken_qubits=[]
        self.get_randomly_bases_alice()
        self.get_randomly_bases_bob()
        self.send_qubits_alice()
        self.received_qubits_bob()
        i=0
        while i < self.long_message:
            if self.she_send_randomly_bases[i] == self.he_send_randomly_bases[i]:
                self.taken_qubits.append(self.qubits_alice[i])
            else:
                self.taken_qubits.append(self.qubits_bob[i])
            i=i+1
        return self.taken_qubits
        
        
    def generate_key(self): #generated by the key itself on the trail
        self.key=[]
        i=0
        while i < self.long_message:
            if self.she_send_randomly_bases[i] == self.he_send_randomly_bases[i]:
                c=self.taken_qubits[i]
                if c[0][0]==0:
                    self.key.append(1)
                else:
                    self.key.append(0)
            else:
                pass
            i=i+1
            
    def __repr__(self): 
        return "Key: " + str(self.key)
            
a=Alice(4,10)
a.get_randomly_bases_alice()
a.send_qubits_alice()
b=Bob(4,10)
b.get_randomly_bases_bob()
b.received_qubits_bob()
c=Various_measurement(4,10)
c.compare_bob_alice()
c.generate_key()
print(c.key)

        
        
        
        


    

        
        
        


