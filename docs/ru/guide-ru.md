# HIDDEN INFORMATION Документация
* [Главная](index.md)
* [Руководство пользователя](guide-ru.md)
***

## Квантовая Криптография
Квантовая   криптография-наука об использовании квантово-механических свойств для выполнения криптографических задач.
Главное преимущество квантового криптографического протокола - невозможность перехватчику остаться незамеченным при
внесении помехи. Это связано со совйством волновой функции, которое означает, что любое изменение квантовой системы
меняет ее исходное состоние. Таким образом, невозможно достоверно различить квантовые состояния из их не ортогонального
набора. При попытке  узнать информацию перехватчик неизбежно вносит помеху, в результате чего он может быть вычислен
на приемной стороне.  Когда ошибка  близка к критической величине (зависит от используемого протокола) длина ключа
стремится к нулю и передача информации становится невозможной.  Чем больше значение критической ошибки для данной
системы, тем она устойчивей.
Мы рассматриваем одну из технологий передачи конфиденциальной информации. Открытая передача сообщения по открытому каналу, но лишь после специального преобразования - *шифрования*. Подразумевается невозможность получения полезной информациии без *секретного ключа*.
### Протоколы квантового распределения ключа
- BB84

[Как работает протокол bb84?](https://github.com/AnastasiaKhrabraya/HI/blob/master/docs/img/bb84-ru.jpg)
![](/img/bb84-ru.jpg)

*Общая схема протокола*:
Традиционно в работах по криптографии легитимных пользователей принято кратко обозначать как Алису и Боба, а перехватчика называть Евой. Таким образом, описание ситуации в криптографическом протоколе выглядит так: Алиса должна передать Бобу секретное сообщение, а Ева всеми доступными ей средствами старается его перехватить. На первом этапе Алиса посылает отдельные фотоны Бобу в произвольно выбранном базисе, используя при выборе генератор случайных чисел. Отдельные фотоны могут посылаться все вместе или один за другим, единственное ограничение состоит в том, чтобы Алиса и Боб смогли установить взаимно однозначное соответствие между посланным и принятым фотоном. Боб измеряет принимаемые фотоны в одном из двух базисов, также выбираемых произвольно (и независимо от выбора Алисы). На данном этапе в случае использования одинаковых базисов они получают абсолютно коррелированные результаты. Однако в случае использования различных базисов они получают некоррелированные результаты. В среднем Боб получает строку битов с 25 % ошибок, называемую первичным ключом. Эта ошибка настолько велика, что использование стандартных алгоритмов коррекции ошибок
невозможно. Тем не менее, можно провести следующую процедуру, называемую согласованием базисов: для каждого переданного
состояния Боб открыто сообщает, в каком базисе проводилось измерение кубита (но не сообщает результатов измерений).
Алиса затем сообщает, в каких случаях её базис совпал с базисом Боба. Если базисы совпали, бит оставляют, если же нет,
его игнорируют. В таком случае примерно 50 % данных выбрасывается. Оставшийся более короткий ключ называется «просеянным». В случае отсутствия подслушивания и шумов в канале связи Алиса и Боб будут теперь иметь полностью коррелированную строку случайных битов, которая будет в дальнейшем использоваться в схемах классической симметричной криптографии. Если же подслушивание имело место, то по величине ошибки в получившемся классическом канале связи Алиса и Боб могут оценить максимальное количество информации, доступное Еве. Существует оценка, что если ошибка в канале меньше приблизительно 11 %, то информация, доступная Еве, заведомо не превосходит взаимной информации между Алисой и Бобом, и секретная передача данных возможна.

- SARG04

*Общая схема протокола*:
Протокол SARG04 нацелен на улучшение надежности основных протоколов в квантовой криптографии (в первую очередь, BB84 и B92) против PNS атак в случае применения слабых когерентных импульсов вместо сигналов единичных частиц. Первый этап протокола SARG04 такой же как и в BB84. На втором этапе Алиса и Боб определяют базисы, но Алиса не сразу сообщает свой базис Бобу. Она объявляет пару неортогональных состояний, которые она использовала для кодирования сообщения. Если Боб использовал правильный базис, то он получит правильное сообщение. Если он выбрал базис неправильно - не сможет определить битовую последовательность корректно. Использование нескольких фотонов привело к появлению PNS атак. Ева отщепляет один фотон или небольшое число фотонов от каждой передачи битов для измерений. Это позволиляет Еве получать фотоны не нарушая сообщение Боба. Протокол SARG04 устойчив к PNS атакам, поскольку Алиса не сразу сообщает свой базис. Она показывает пару неортогональных состояний, в которых бит может быть закодирован. Если боб выбрал правильный базис, он обнаружит, что измерил одну из этих двух состояний, которые передала Алиса. В противном случае бит отбрасывается. Это означает, что Ева не знает, какой базис был использован для передачи, даже после того, как Алиса и Боб выбрали базис для расшифровки.

## HI Библиотека

### Концепция

Алиса записывает строку из базисов, преобразует кубиты в соответствии с ними. Затем Боб создаёт свою строку из базисов. Базисы сравниваются и на месте верно выбранных, мы получаем кубиты. Записываем ключ.

### Алгоритм

Для реализации алгоритма был использован язык программирования Python и библиотеки Math и Numpy.

    class Qubit:
    def __init__(self,state_1=None):
    if state_1==None:
    state_1=np.random.random()
    state_2=math.sqrt(1-(state_1**2))
    self.qubit=np.array([[state_1,state_2]])
    def __repr__(self):
    return "qubit: " + str(self.qubit)

Класс для кубита , который описывает его состояние на сфере Блоха без учета углов. Сначала задается одно состояние для вектора кет `def __init__(self,state_1=None):`. Если состояние_1 не задано, значит это перепутанные состояния.
В других случаях состоянии равны 0 или 1.
Функция `def __repr__(self): return "qubit: " + str(self.qubit)` необходима для выведения кубита на экран.
Для того чтобы задать кубит необходимо ввести (пользователь вводит значения 1 или 0):

    particle= Qubit(1)
    particle. qubit

Перейдем к описанию класса гейта Адамара:

    class Hadamard():
    def __init__(self):
    self.apply_Hadamard = np.array([[1/math.sqrt(2),1/math.sqrt(2)],[1/math.sqrt(2),-1/math.sqrt(2)]])
    def __repr__(self): #a method for outputting a qubit
    return "Hadamard: " + str(self.apply_Hadamard)

Гейт Адамара является одним из наиболее полезных квантовых гейтов. Этот гейт иногда определяют как квадратный корень от NOT гейт. Это связано с тем, что данный гейт преобразует `|0>` часть кубита в `(|0>+|1>)/√2`. Это половина расстояния  между `|0>` и`|1>` состояниями в геометрической интерпретации кубита на сфере Блоха. Соответственно, `|1>` часть кубита преобразуется гейтом Адамара в комбинацию `(|0> - |1>)/√2`, которая также является половиной расстояния между `|0>` и `|1>`. Но HxH гейт не приводит к  NOT гейту, поскольку алгебраические вычисления дают HxH ≡ I. Таким образом, двухкратное применение гейта H возвращает систему в исходное состояние. Функция выглядит следующим образом:

    matrix= Hadamard()
    matrix. apply_Hadamard

Запишем класс NOT:

    class NOT():
    def __init__(self):
    self.apply_NOT = np.array([[0,1],[1,0]])
    def __repr__(self):
    return "NOT: " + str(self.apply_NOT)

Класс меняет состояния местами. Из кубита, который определяется матрицей (0,1), получится (1,0).

Класс фазового гейта:

    class Gate_pi():
    def __init__(self):
    p = complex(0,math.pi/4)
    p = p.imag
    self.apply_gate_pi = np.array([[1,0],[0,p]])
    def __repr__(self):
    return "Gate_pi: " + str(self.apply_gate_pi)

Класс необходим для поворота векторов базиса на угол пи/4. Пользователю ничего вводить не нужно.

    class Gate_pi8():
    def __init__(self,n):
    p = complex(0,math.pi/8)
    p = p.imag
    self.apply_gate_pi8 = np.array([[math.exp(-p*n),0],[0,math.exp(p*n)]])
    def __repr__(self):
    return "Gate_pi8: " + str(self.apply_gate_pi8)

Класс фазового гейта для поворота векторов базиса на угол пи/8. Пользователю необходимо ввести номер базиса, до которого он хочет повернуть вектора относительно нулевого базиса.

    matrix= Gate_pi8 (ввести базис)
    matrix. apply_gate_pi8

Класс фазового гейта для поворота векторов базиса на какой-либо угол.

    class Gate_turn():
    def __init__(self,n,number_bas):
    p = complex(0,math.pi/number_bas)
    p = p.imag
    self.apply_gate_turn = np.array([[math.exp(-p*n),0],[0,math.exp(p*n)]])
    def __repr__(self):
    return "Gate_turn: " + str(self.apply_gate_turn)

Необходимо ввести два элемента – до какого базиса поворачиваем вектор и шаг поворота.

    matrix= Gate_turn (номер базиса, общее число базисов)
    matrix. apply_gate_turn

Двубитный гейт,то есть действует на 2 кубита, переворачивая их состояния.  

    class CNOT():
    def __init__(self):
    self.apply_CNOT = np.array([[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]])
    def __repr__(self):
    return "Gate_CNOT: " + str(self.apply_CNOT)

Класс генератора . Пользователю необходимо ввести число используемых в протоколе базисов, длину сообщения, которое будем передавать (число  передаваемых кубитов) , индекс запутанности. (0  определяет смешанные состояния, если ничего не вводить, то состоянии станут перепутанными).

    generator = Actor(кол-во используемых базисов, длина сообщения, индекс запутанности):
    generator. send()
    generator. randomly_bases
    generator. message_qubit

Класс для Алисы.

    class Alice(Actor):#Here they take their randomly values
    def get_randomly_bases_alice(self):
    self.send()
    self.she_send_randomly_bases=self.randomly_bases
    return self.she_send_randomly_bases
    def send_qubits_alice(self):
    self.qubits_alice=[]
    i=0
    while i<self.long_message:
    q=Gate_turn(self.she_send_randomly_bases[i],self.number_bas)
    c=np.dot(self.message_qubit[i],q.apply_gate_turn)
    self.qubits_alice.append(c)
    i=i+1

Алиса использует метод генератора и формирует свое сообщение из случайных базисов. В зависимости от выбранного базиса, поворачивает кубиты, воздействуя на них фазовым поворотным гейтом. `Gate_turn a=Alice` (количество используемых базисов, длинна сообщения, индекс запутанности), `a.get_randomly_bases_alice()` Алиса получает случайные базисы, `a.send_qubits_alice()` Алиса передает кубиты .

Класс для Евы.

    class Eve(Alice,Actor):
    def initialized(self):
    self.send()
    self.eve_send_randomly_bases=self.randomly_bases
    self.get_randomly_bases_alice()
    self.send_qubits_alice()
    self.qubits_alice
    twist=np.random.randint(2,10)
    self.clog =np.random.randint(1,twist-1)
    def intercepts_qubits(self):
    self.initialized()
    a=0
    while a<self.long_message:
    if self.eve_send_randomly_bases[a]==self.she_send_randomly_bases[a]:
    q=Gate_turn(a,self.clog)
    c=np.dot(self.qubits_alice[a],q.apply_gate_turn)
    self.qubits_alice[a]=c
    else:
    pass
    a=a+1
    def removes_qubits(self):
    self.initialized()
    a=0
    while a<self.long_message:
    if self.eve_send_randomly_bases[a] == self.she_send_randomly_bases[a]:
    self.qubits_alice.pop(a)
    else:
    pass
    a=a+1
    def add_qubits(self):
    self.initialized()

Ева может изменять кубиты, доворачивая их на какой-либо угол (только если базисы , которые сформировала Алиса и Ева совпали) методом  `def intercepts_qubits(self):`.  Может удалять кубиты (изымать их из передачи) методом  `def removes_qubits(self):`.  Может добавлять в сообщение собственные кубиты , со своей поляризацией `def add_qubits(self):`. Количество используемых базисов, длинна сообщения, индекс запутанности `noise=Eve`. Ева инициализирует связь с Алисой `noise.initialized()`. После точки необходимо написать метод. В нашем случае Ева поворачивает кубиты, которые угадала и вносит ошибку `noise.intercepts_qubits()`.

Класс для Боба.

    class Bob(Actor):
    def get_randomly_bases_bob(self):
    self.send()
    self.he_send_randomly_bases=self.randomly_bases
    return self.he_send_randomly_bases
    def received_qubits_bob(self):
    self.qubits_bob=[]
    i=0
    while i<self.long_message:
    q=Gate_turn(self.he_send_randomly_bases[i],self.number_bas)
    c=np.dot(self.message_qubit[i],q.apply_gate_turn)
    self.qubits_bob.append(c)
    i=i+1

Боб использует метод генератора и формирует свое сообщение из случайных базисов.  В зависимости от выбранного базиса поворачивает кубиты, воздействуя на них фазовым поворотным гейтом `Gate_turn`. Количество используемых базисов, длина сообщения, индекс запутанности `b=Bob`. Боб получает случайные базисы `b.get_randomly_bases_bob()`. Боб получает измеренные кубиты `b.received_qubits_bob()`.

Различные операции с кубитами.

    class Various_measurement(Alice,Bob,Actor):

    def compare_bob_alice(self): #Alice and Bob compare their bases and this
    #forms the following key. If the bases are equal to the true value,
    #if not - then the value of Bob
    self.taken_qubits=[]
    self.get_randomly_bases_alice()
    self.get_randomly_bases_bob()
    self.send_qubits_alice()
    self.received_qubits_bob()
    i=0
    while i < self.long_message:
    if self.she_send_randomly_bases[i] == self.he_send_randomly_bases[i]:
    self.taken_qubits.append(self.qubits_alice[i])
    else:
    self.taken_qubits.append(self.qubits_bob[i])
    i=i+1
    return self.taken_qubits

    def generate_key(self): #generated by the key itself on the trail
    self.key=[]
    i=0
    while i < self.long_message:
    if self.she_send_randomly_bases[i] == self.he_send_randomly_bases[i]:
    c=self.taken_qubits[i]
    if c[0][0]==0:
    self.key.append(1)
    else:
    self.key.append(0)
    else:
    pass

Различные операции с кубитами определяются методом сравнения базисов , если базис правильно угадан Бобом,то используется кубит Алисы, если нет, кубит приходит ошибочный `def compare_bob_alice(self)`. Количество используемых базисов, длина сообщения, индекс запутанности `c=Various_measurement`.  Базисы Алисы и Боба сравниваются , формируется массив полученных кубитов`c.compare_bob_alice()`. Формируется ключ `c.generate_key()`.

### Возможности библиотеки

Библиотека позволяет создать инструмент прототипирования квантового распредления ключей. Это применимо в изучении и отладки квантовых протоколов. Классы для кубитов, методы генерации и получения сообщения универсальны и могут быть использованы для различных задач квантовой криптографии. Библиотека содержит блоки кода, где пользователь может вводить данные и получать собственные результаты. Описание использование классов приведено выше.

### Примеры

Пример формирования ключа протокола BB84 с участие Евы :

    a=Alice(4,10,0)
    a.get_randomly_bases_alice()
    a.send_qubits_alice()
    noise=Eve(4,10,0)
    noise.initialized()
    noise.intercepts_qubits()

    b=Bob(4,10,0)
    b.get_randomly_bases_bob()
    b.received_qubits_bob()

    c=Various_measurement(4,10,0)
    c.compare_bob_alice()
    c.generate_key()
    print(c.key)

Пример формирования ключа протокола BB84 без участия Евы :

    a=Alice(4,10,0)
    a.get_randomly_bases_alice()
    a.send_qubits_alice()

    b=Bob(4,10,0)
    b.get_randomly_bases_bob()
    b.received_qubits_bob()

    c=Various_measurement(4,10,0)
    c.compare_bob_alice()
    c.generate_key()
    print(c.key)

***

* [Благодарности](thanks-ru.md)
* [Справка](ref-ru.md)
